Shell中打印匹配关键字的前后行 [echo、grep用法]

 

在日常运维中，经常需要监控某个进程，并打印某个进程的监控结果，通常需要打印匹配某个结果的行以及其前后各N行。

这里注意下：echo使用-e参数，对打印的结果中进行\n换行

|   |   |
| - | - |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22 | [root@mq-master02 ~]\# echo "abcd"<br>abcd<br>[root@mq-master02 ~]\# echo "ab\\ncd"<br>ab\\ncd<br>[root@mq-master02 ~]\# echo "ab \\n cd"<br>ab \\n cd<br>[root@mq-master02 ~]\# echo -e "ab\\ncd"<br>ab<br>cd<br>[root@mq-master02 ~]\# echo -e "ab \\n cd"<br>ab<br> cd<br>[root@mq-master02 ~]\# echo -e "ab \\n cd \\n \\n df"<br>ab<br> cd<br>  <br> df<br> [root@mq-master02 ~]\# echo -e "ab\\ncd \\n \\ndf"  <br>ab<br>cd<br>  <br>df |


echo的-n、-e参数：

|   |   |
| - | - |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26 | 1）echo -n 表示：不换行输出<br>[root@mq-master02 ~]\# echo "123"  <br>123<br>[root@mq-master02 ~]\# echo -n "123"<br>123[root@mq-master02 ~]\#<br> <br>2）echo -e 表示：处理特殊字符。若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：<br>\\a 发出警告声；<br>\\b 删除前一个字符；<br>\\c 最后不加上换行符号；<br>\\f 换行但光标仍旧停留在原来的位置；<br>\\n 换行且光标移至行首；<br>\\r 光标移至行首，但不换行；<br>\\t 插入tab；<br>\\v 与\\f相同；<br>\\\\ 插入\\字符；<br>\\nnn 插入nnn（八进制）所代表的ASCII字符；<br> <br>[root@mq-master02 ~]\# echo "123\\n456"<br>123\\n456<br>[root@mq-master02 ~]\# echo -e "123\\n456"<br>123<br>456<br> <br>[root@mq-master02 ~]\# echo -e "wang\\bkevin"<br>wankevin |


echo后面跟双引号或单引号问题：

|   |   |
| - | - |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36 | 使用echo输出字符串时候，无论单引号还是双引号都是一样的。<br>如果字符串中有变量，单引号会忽略，而双引号会把变量解析以后带入字符串。<br>也就是说，echo后面的单引号就是一般输出，对引号里面的变量和特殊操作符号都不识别。<br> <br>echo后面跟双引号，双引号里能识别变量和特殊操作符号；<br>echo后面跟单引号，单引号里不会识别变量和特殊操作符号；<br> <br>示例：<br>[root@localhost ~]\# aa=123      <br>[root@localhost ~]\# echo "${aa}"<br>123<br>[root@localhost ~]\# echo '${aa}'<br>${aa}<br> <br>如下，将kill -9 `ps -ef|grep web\_server|awk '{print $2}'`这条命令追加到web\_script.sh脚本中，正确写法如下：<br>由于要保留kill命令后面``操作语句中的单引号和$2，所以单引号和$2前面都要加转义符\\。<br>下面示例中echo后面加不加-e参数，效果都一样！<br>[root@localhost ~]\# echo -e "kill -9 \\`ps -ef|grep web\_server|awk '{print \\$2}'\\`" &gt;&gt; 123.sh<br>[root@localhost ~]\# cat 123.sh<br>kill -9 `ps -ef|grep web\_server|awk '{print $2}'`<br> <br>如果不加转移符号，则echo后面的双引号就会直接识别出``执行之后的结果，就将web\_server的pid打印出来了<br>[root@localhost ~]\# echo -e "kill -9 `ps -ef|grep web\_server|awk '{print $2}'`" &gt;&gt; 123.sh<br>[root@localhost ~]\# cat 123.sh<br>kill -9 9850<br> <br>如果echo不使用双引号，使用单引号，则结果中会把$2内容给抹掉。<br>[root@localhost ~]\# echo -e 'kill -9 `ps -ef|grep web\_server|awk '{print $2}'`' &gt;&gt; 123.sh <br>[root@localhost ~]\# cat 123.sh<br>kill -9 `ps -ef|grep web\_server|awk {print }`<br> <br>如果echo使用单引号，在单引号里面使用双引号，如下，在echo的单引号里将awk后面的内容用双引号，则$2会保留。<br>但是awk后面必须是单引号才能正确print，awk后面跟单引号就没有意义了！<br>[root@localhost ~]\# echo -e 'kill -9 `ps -ef|grep web\_server|awk "{print $2}"`' &gt;&gt; 123.sh<br>[root@localhost ~]\# cat 123.sh<br>kill -9 `ps -ef|grep web\_server|awk "{print $2}"` |


示例1

|   |   |
| - | - |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108 | [root@mq-master02 ~]\# cat /opt/test<br>192.168.10.11<br>Don't worry! main is running!<br>192.168.10.12<br>Don't worry! main is running!<br>192.168.10.13<br>It's so bad! main is failed!<br>192.168.10.14<br>Don't worry! main is running!<br>192.168.10.15<br>Don't worry! main is running!<br>192.168.10.16<br>It's so bad! main is failed!<br>192.168.10.17<br>Don't worry! main is running!<br>192.168.10.18<br>Don't worry! main is running!<br>192.168.10.19<br>Don't worry! main is running!<br>192.168.10.20<br>Don't worry! main is running!<br>192.168.10.21<br>Don't worry! main is running!<br>192.168.10.12<br>Don't worry! main is running!<br> <br>1）打印/opt/test中所有匹配"main is failed"的行<br>[root@mq-master02 ~]\# cat /opt/test |grep "main is failed"<br>It's so bad! main is failed!<br>It's so bad! main is failed!<br>[root@mq-master02 ~]\# sed -n '/main is failed/p' /opt/test<br>It's so bad! main is failed!<br>It's so bad! main is failed!<br> <br>2）打印/opt/test中所有匹配"main is failed"的行及其前1行<br>[root@mq-master02 ~]\# cat /opt/test |grep "main is failed" -B1  <br>192.168.10.13<br>It's so bad! main is failed!<br>--<br>192.168.10.16<br>It's so bad! main is failed!<br> <br>3）打印/opt/test中所有匹配"main is failed"的行及其后1行<br>[root@mq-master02 ~]\# cat /opt/test |grep "main is failed" -A1<br>It's so bad! main is failed!<br>192.168.10.14<br>--<br>It's so bad! main is failed!<br>192.168.10.17<br> <br>4）打印/opt/test中所有匹配"main is failed"的行及其前后各1行<br>[root@mq-master02 ~]\# cat /opt/test |grep "main is failed" -C1<br>192.168.10.13<br>It's so bad! main is failed!<br>192.168.10.14<br>--<br>192.168.10.16<br>It's so bad! main is failed!<br>192.168.10.17<br> <br>5）把/opt/test中所有匹配"main is failed"的行及其前1行的结果打印到/root/result.log中，并加上时间<br>[root@mq-master02 ~]\# echo -e "$(date)\\n$(cat /opt/test|grep "main is failed" -B1)"&gt; /root/result.log<br>[root@mq-master02 ~]\# cat /root/result.log<br>Wed Oct 10 20:34:15 CST 2018<br>192.168.10.13<br>It's so bad! main is failed!<br>--<br>192.168.10.16<br>It's so bad! main is failed!<br> <br>[root@mq-master02 ~]\# echo -e "$(date)\\n$(cat /opt/test|grep "main is failed" -B1) \\n" &gt; /root/result.log<br>[root@mq-master02 ~]\# echo -e "$(date)\\n$(cat /opt/test|grep "main is failed" -B1) \\n" &gt;&gt; /root/result.log<br>[root@mq-master02 ~]\# echo -e "$(date)\\n$(cat /opt/test|grep "main is failed" -B1) \\n" &gt;&gt; /root/result.log<br>[root@mq-master02 ~]\# cat /root/result.log<br>Wed Oct 10 20:35:27 CST 2018<br>192.168.10.13<br>It's so bad! main is failed!<br>--<br>192.168.10.16<br>It's so bad! main is failed!<br> <br>Wed Oct 10 20:35:29 CST 2018<br>192.168.10.13<br>It's so bad! main is failed!<br>--<br>192.168.10.16<br>It's so bad! main is failed!<br> <br>Wed Oct 10 20:35:29 CST 2018<br>192.168.10.13<br>It's so bad! main is failed!<br>--<br>192.168.10.16<br>It's so bad! main is failed!<br> <br>[root@mq-master02 ~]\# echo -e "$(date +%Y年%m月%d日) $(date +%A) $(date +%H时%M分%S秒)\\n$(echo "今天是个好日子啊") \\n" &gt; /root/result.log<br>You have new mail in /var/spool/mail/root<br>[root@mq-master02 ~]\# echo -e "$(date +%Y年%m月%d日) $(date +%A) $(date +%H时%M分%S秒)\\n$(echo "今天是个好日子啊") \\n" &gt;&gt; /root/result.log<br>[root@mq-master02 ~]\# echo -e "$(date +%Y年%m月%d日) $(date +%A) $(date +%H时%M分%S秒)\\n$(echo "今天是个好日子啊") \\n" &gt;&gt; /root/result.log<br>[root@mq-master02 ~]\# cat /root/result.log<br>2018年10月10日 Wednesday 20时36分49秒<br>今天是个好日子啊<br> <br>2018年10月10日 Wednesday 20时36分52秒<br>今天是个好日子啊<br> <br>2018年10月10日 Wednesday 20时36分54秒<br>今天是个好日子啊 |


示例2

|   |   |
| - | - |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101 | ip列表文件<br>[root@kevin ~]\# cat /opt/ip.list<br>192.168.10.11<br>192.168.10.12  <br>192.168.10.13  <br>192.168.10.14<br>192.168.10.15<br>192.168.10.16<br>192.168.10.17<br>  <br>  <br>main进程状态的检查脚本：<br>[root@kevin ~]\# cat /opt/script/6\_main\_check.sh<br>\#!/bin/bash<br>  <br>for i in $(cat /opt/ip.list)<br>do<br>/usr/bin/rsync -e "ssh -p22" -avpgolr /usr/bin/main\_check $i:/usr/bin/ &gt; /dev/null 2&gt;&amp;1<br>ssh -p22 root@$i "echo $i;sh /usr/bin/main\_check"<br>done<br>  <br>[root@kevin ~]\# cat /usr/bin/main\_check<br>\#!/bin/bash<br>NUM=$(ps -ef|grep -w main|grep -v grep|wc -l)<br>if [ $NUM -eq 0 ];then<br>   echo "Oh!My God! It's broken! main is stoped!"<br>else<br>   echo "Don't worry! main is running!"<br>fi<br>  <br>  <br>检查脚本执行结果<br>[root@kevin ~]\# sh /opt/script/6\_main\_check.sh<br>192.168.10.11<br>Don't worry! main is running!<br>192.168.10.12<br>Don't worry! main is running!<br>192.168.10.13<br>Don't worry! main is running!<br>192.168.10.14<br>Don't worry! main is running!<br>192.168.10.15<br>Don't worry! main is running!<br>192.168.10.16<br>Don't worry! main is running!<br>192.168.10.17<br>Don't worry! main is running!<br>  <br>检查脚本执行结果的打印脚本<br>[root@kevin ~]\# cat /mnt/main\_check\_result.sh<br>\#!/bin/bash<br>NUM=$(/bin/bash /opt/script/6\_main\_check.sh |grep -w "main is stoped"|wc -l)<br>CONTENT=$(/bin/bash /opt/script/6\_main\_check.sh |grep -w "main is stoped")<br>if [ $NUM -ne 0 ];then<br>    echo -e "$(date +%Y年%m月%d日) $(date +%A) $(date +%H时%M分%S秒)\\n$(/bin/bash /opt/script/6\_main\_check.sh |grep  "main is stoped" -B1)\\n"&gt;&gt; /mnt/main\_check\_result.log<br>else<br>    echo -e "$(date +%Y年%m月%d日) $(date +%A) $(date +%H时%M分%S秒)\\n$(echo "当前时段所有机器的main进程运行正常,无需担心哈!")\\n"&gt;&gt; /mnt/main\_check\_result.log<br>fi<br>  <br>main检查的结果文件内容<br>[root@kevin ~]\# cat /mnt/main\_check\_result.log<br>2018年10月10日 星期三 20时30分41秒<br>当前时段所有机器的main进程运行正常,无需担心哈!<br>  <br>2018年10月10日 Wednesday 20时30分46秒<br>当前时段所有机器的main进程运行正常,无需担心哈!<br>  <br>2018年10月10日 Wednesday 20时35分45秒<br>当前时段所有机器的main进程运行正常,无需担心哈!<br>  <br>2018年10月10日 Wednesday 20时40分45秒<br>当前时段所有机器的main进程运行正常,无需担心哈!<br> <br>以上的脚本：不管main进程状态检查结果是否正常，都打印一个结果到/mnt/main\_check\_result.log文件中，<br>其实检查结果正常的时候，可以不必打印结果（即echo "\*\*\*\*" &gt; /dev/null 2 &gt;&amp;1）；<br>只有检查结果不正常的时候才打印结果，这样比较好点。<br> <br>对/mnt/main\_check\_result.log文件大小做判断，当该文件大于60M(即61865984)时就清空。<br> <br>[root@kevin ~]\# ls -l /mnt/main\_check\_result.log<br>-rw-r--r--. 1 root root 16998 Nov 19  2017 /mnt/main\_check\_result.log<br> <br>[root@kevin ~]\# ls -l /mnt/main\_check\_result.log|awk '{print $5}'<br>16998<br> <br>[root@kevin ~]\# ls -l /mnt/main\_check\_result.log|awk '{print $9}'<br>/mnt/main\_check\_result.log<br> <br>[root@kevin ~]\# vim /root/main\_check\_result.log\_del.sh<br>\#!/bin/bash<br>size=$(ls -l /mnt/main\_check\_result.log|awk '{print $5}')<br>file=$(ls -l /mnt/main\_check\_result.log|awk '{print $9}')<br> <br>if [ $size -gt 61865984 ] ; then<br>    echo $file; echo $size<br>    echo &gt;$file<br>fi<br> <br>[root@kevin ~]\# chmod 755 /root/main\_check\_result.log\_del.sh<br>[root@kevin ~]\# crontab -e<br>0 1 \* \* 6 /bin/bash -x /root/main\_check\_result.log\_del.sh &gt;/dev/null 2&gt;&amp;1 |


*************** 当你发现自己的才华撑不起野心时，就请安静下来学习吧！***************
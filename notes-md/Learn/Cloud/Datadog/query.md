### 示例数据

假设我们有以下 qe_health_status 指标数据（每分钟两个数据点）：

```
时间戳       | pod_name | qe_health_status
------------------------------------------
16:00:00     | pod1     | 1
16:00:30     | pod1     | 2
16:01:00     | pod1     | 3
16:01:30     | pod1     | 4
16:02:00     | pod1     | 5
16:02:30     | pod1     | 6
16:03:00     | pod1     | 7
16:03:30     | pod1     | 8
16:04:00     | pod1     | 9
16:04:30     | pod1     | 10

```

### 简单来说，

.rollup(sum, 60) 强制将数据按60秒的间隔进行汇总，而没有 .rollup(sum, 60) 的查询会根据Datadog的默认设置进行汇总

在Datadog中，默认的汇总时间间隔并不是固定的60秒，而是根据具体的查询和数据源的不同，数据的粒度和查询的时间范围而变化而有所变化

**查询语句1**

```
avg(last_4m):sum:a552014_ets_qe_${var.environment}_otlp.qe_health_status{region:${var.region},otellib:ets-qe-meter} by {pod_name}.rollup(sum, 60) >= 3
```

**解释**:

过去4分钟内的数据点：16:00:00 到 16:04:30

每分钟的 qe_health_status 求和：

- 16:00:00: 1 + 2 = 3

- 16:01:00: 3 + 4 = 7

- 16:02:00: 5 + 6 = 11

- 16:03:00: 7 + 8 = 15

- 16:04:00: 9 + 10 = 19

每分钟的滚动求和（60秒）：

- 16:00:00: 3

- 16:01:00: 7

- 16:02:00: 11

- 16:03:00: 15

- 16:04:00: 19

**控制台输出**:

```
时间戳       | pod_name | 滚动求和
--------------------------------
16:00:00     | pod1     | 3
16:01:00     | pod1     | 7
16:02:00     | pod1     | 11
16:03:00     | pod1     | 15
16:04:00     | pod1     | 19

```

### 查询语句2

```
avg(last_4m):sum:a552014_ets_qe_${var.environment}_otlp.qe_health_status{region:${var.region},otellib:ets-qe-meter} by {pod_name}.rollup(avg, 60) >= 3
.rollup(avg, 60) 不会覆盖前面的 sum，而是对每个60秒时间段内的求和结果进行平均值计算
```

**解释**:

过去4分钟内的数据点：16:00:00 到 16:04:30

每分钟的 qe_health_status 求和：

- 16:00:00: 1 + 2 = 3

- 16:01:00: 3 + 4 = 7

- 16:02:00: 5 + 6 = 11

- 16:03:00: 7 + 8 = 15

- 16:04:00: 9 + 10 = 19

每分钟的滚动平均（60秒）：

- 16:00:00: 3 / 2 = 1.5

- 16:01:00: 7 / 2 = 3.5

- 16:02:00: 11 / 2 = 5.5

- 16:03:00: 15 / 2 = 7.5

- 16:04:00: 19 / 2 = 9.5

**控制台输出**:

```
时间戳       | pod_name | 滚动平均
--------------------------------
16:00:00     | pod1     | 1.5
16:01:00     | pod1     | 3.5
16:02:00     | pod1     | 5.5
16:03:00     | pod1     | 7.5
16:04:00     | pod1     | 9.5

```

### 查询语句3

```
avg(last_4m):avg:a552014_ets_qe_${var.environment}_otlp.qe_health_status{region:${var.region},otellib:ets-qe-meter} by {pod_name}.rollup(sum, 60) >= 3

```

**解释**:

过去4分钟内的数据点：16:00:00 到 16:04:30

每分钟的 qe_health_status 平均值：

- 16:00:00: (1 + 2) / 2 = 1.5

- 16:01:00: (3 + 4) / 2 = 3.5

- 16:02:00: (5 + 6) / 2 = 5.5

- 16:03:00: (7 + 8) / 2 = 7.5

- 16:04:00: (9 + 10) / 2 = 9.5

每分钟的滚动求和（60秒）：

- 16:00:00: 1.5

- 16:01:00: 3.5

- 16:02:00: 5.5

- 16:03:00: 7.5

- 16:04:00: 9.5

**控制台输出**:

```
时间戳       | pod_name | 滚动求和
--------------------------------
16:00:00     | pod1     | 1.5
16:01:00     | pod1     | 3.5
16:02:00     | pod1     | 5.5
16:03:00     | pod1     | 7.5
16:04:00     | pod1     | 9.5

```

### 查询语句4

```
avg(last_4m):avg:a552014_ets_qe_${var.environment}_otlp.qe_health_status{region:${var.region},otellib:ets-qe-meter} by {pod_name}.rollup(avg, 60) >= 3

```

**解释**:

过去4分钟内的数据点：16:00:00 到 16:04:30

每分钟的 qe_health_status 平均值：

- 16:00:00: (1 + 2) / 2 = 1.5

- 16:01:00: (3 + 4) / 2 = 3.5

- 16:02:00: (5 + 6) / 2 = 5.5

- 16:03:00: (7 + 8) / 2 = 7.5

- 16:04:00: (9 + 10) / 2 = 9.5

每分钟的滚动平均（60秒）：

- 16:00:00: 1.5

- 16:01:00: 3.5

- 16:02:00: 5.5

- 16:03:00: 7.5

- 16:04:00: 9.5

**控制台输出**:

```
时间戳       | pod_name | 滚动平均
--------------------------------
16:00:00     | pod1     | 1.5
16:01:00     | pod1     | 3.5
16:02:00     | pod1     | 5.5
16:03:00     | pod1     | 7.5
16:04:00     | pod1     | 9.5
```

### 查询语句5

```
avg(last_4m):sum:a552014_ets_qe_${var.environment}_otlp.qe_health_status{region:${var.region},otellib:ets-qe-meter} by {pod_name}.rollup(sum, 30) >= 3

```

**解释**:

过去4分钟内的数据点：16:00:00 到 16:04:30

每分钟的 qe_health_status 求和：

- 16:00:00: 1

- 16:00:30: 2

- 16:01:00: 3

- 16:01:30: 4

- 16:02:00: 5

- 16:02:30: 6

- 16:03:00: 7

- 16:03:30: 8

- 16:04:00: 9

- 16:04:30: 10

每30秒的滚动求和：

- 16:00:00: 1

- 16:00:30: 2

- 16:01:00: 3

- 16:01:30: 4

- 16:02:00: 5

- 16:02:30: 6

- 16:03:00: 7

- 16:03:30: 8

- 16:04:00: 9

- 16:04:30: 10

**控制台输出**:

```
时间戳       | pod_name | 滚动求和
--------------------------------
16:00:00     | pod1     | 1
16:00:30     | pod1     | 2
16:01:00     | pod1     | 3
16:01:30     | pod1     | 4
16:02:00     | pod1     | 5
16:02:30     | pod1     | 6
16:03:00     | pod1     | 7
16:03:30     | pod1     | 8
16:04:00     | pod1     | 9
16:04:30     | pod1     | 10

```

### 查询语句6

```
avg(last_4m):sum:a552014_ets_qe_${var.environment}_otlp.qe_health_status{region:${var.region},otellib:ets-qe-meter} by {pod_name} >= 3

```

**解释**:

过去4分钟内的数据点：16:00:00 到 16:04:30

每分钟的 qe_health_status 求和：

- 16:00:00: 1 + 2 = 3

- 16:01:00: 3 + 4 = 7

- 16:02:00: 5 + 6 = 11

- 16:03:00: 7 + 8 = 15

- 16:04:00: 9 + 10 = 19

每分钟的求和（默认时间窗口1分钟）：

- 16:00:00: 3

- 16:01:00: 7

- 16:02:00: 11

- 16:03:00: 15

- 16:04:00: 19

**控制台输出**:

```
时间戳       | pod_name | 求和
--------------------------------
16:00:00     | pod1     | 3
16:01:00     | pod1     | 7
16:02:00     | pod1     | 11
16:03:00     | pod1     | 15
16:04:00     | pod1     | 19

```

### 查询语句7

```
sum(last_4m):sum:a552014_ets_qe_${var.environment}_otlp.qe_health_status{region:${var.region},otellib:ets-qe-meter} by {pod_name}.rollup(sum, 60) >= 3

```

**解释**:

过去4分钟内的数据点：16:00:00 到 16:04:30

每分钟的 qe_health_status 求和：

- 16:00:00: 1 + 2 = 3

- 16:01:00: 3 + 4 = 7

- 16:02:00: 5 + 6 = 11

- 16:03:00: 7 + 8 = 15

- 16:04:00: 9 + 10 = 19

每分钟的滚动求和（60秒）：

- 16:00:00: 3

- 16:01:00: 7

- 16:02:00: 11

- 16:03:00: 15

- 16:04:00: 19

**控制台输出**:

```
时间戳       | pod_name | 滚动求和
--------------------------------
16:00:00     | pod1     | 3
16:01:00     | pod1     | 7
16:02:00     | pod1     | 11
16:03:00     | pod1     | 15
16:04:00     | pod1     | 19

```

### 查询语句8

```
sum(last_4m):avg:a552014_ets_qe_${var.environment}_otlp.qe_health_status{region:${var.region},otellib:ets-qe-meter} by {pod_name}.rollup(sum, 60) >= 3

```

**解释**:

过去4分钟内的数据点：16:00:00 到 16:04:30

每分钟的 qe_health_status 平均值：

- 16:00:00: (1 + 2) / 2 = 1.5

- 16:01:00: (3 + 4) / 2 = 3.5

- 16:02:00: (5 + 6) / 2 = 5.5

- 16:03:00: (7 + 8) / 2 = 7.5

- 16:04:00: (9 + 10) / 2 = 9.5

每分钟的滚动求和（60秒）：

- 16:00:00: 1.5

- 16:01:00: 3.5

- 16:02:00: 5.5

- 16:03:00: 7.5

- 16:04:00: 9.5

**控制台输出**:

```
时间戳       | pod_name | 滚动求和
--------------------------------
16:00:00     | pod1     | 1.5
16:01:00     | pod1     | 3.5
16:02:00     | pod1     | 5.5
16:03:00     | pod1     | 7.5
16:04:00     | pod1     | 9.5
```

### avg前缀

sum(last_4m):avg:system.cpu.user{region:us-east}

这表示：

1. **avg:**：对 host1、host2、host3 在每个时间点的值取平均 → 得到一个平均时间序列。

1. **sum(last_4m):**：对这个平均时间序列，在过去 4 分钟内的所有点求和 → 得到一个单一值。

| 聚合层级 | 示例 | 聚合方向 | 结果类型 | 说明 | 
| -- | -- | -- | -- | -- |
| 空间聚合 | avg: | 横向（ | 时间序列 | 多个时间序列 → 一个时间序列 | 
| 时间聚合 | sum(last_4m): | 纵向（ | 单一值或低频序列 | 一个时间序列 → 单一值或更粗粒度序列 | 


### 括号表示“**时间窗口聚合**”！

Datadog 的聚合函数有两种形式：

#### ✅ 1. **不带括号的聚合前缀（如 ****avg:****、****sum:****）**

- 作用：**在每个时间点上，对多个时间序列进行聚合**。

- 聚合方向：**横向（空间聚合）**

- avg:system.cpu.user{host:host1,host2} → 每个时间点上，对 host1 和 host2 的值取平均，结果是把多个时间序列合并成一个时间序列。

- 它的作用是：**在每个时间点上，对所有匹配的时间序列（例如多个主机、Pod(多个metric?)）进行聚合**。

- 所以它不会改变时间序列的时间粒度，也不会减少时间点的数量。

#### ✅ 2. **带括号的聚合函数（如 ****sum(last_4m):****、****avg(last_5m):****）**

- 作用：**在时间维度上，对一个时间序列在指定时间窗口内进行聚合**。

- 聚合方向：**纵向（时间聚合）**

- sum(last_4m):avg:system.cpu.user{host:host1,host2} → 先对 host1 和 host2 的值在每个时间点上取平均（avg:），然后在过去 4 分钟内对这个平均值序列求和（sum(last_4m):），结果是一个**单一值**或**更低分辨率的时间序列**。

| 特性 | .rollup(avg, 60) | avg(last_1m): | 
| -- | -- | -- |
| 输出类型 | 时间序列 | 单一值（或低频序列） | 
| 用途 | 图表趋势、平滑 | 告警、SLO、摘要 | 
| 每个点的含义 | 每 60 秒内的平均值 | 当前时间 | 
| 是否连续 | 是 | 否（通常是单点） | 


| 表达式 | 聚合方向 | 聚合对象 | 是否改变时间粒度 | 
| -- | -- | -- | -- |
| sum:metric{...} | 空间聚合（横向） | 多个时间序列在同一时间点 | ❌ 不改变 | 
| sum(last_5m):metric{...} | 时间聚合（纵向） | 单个时间序列在时间窗口内 | ✅ 改变 | 
| per_minute(metric{...}) | 时间导数（速率）+ 默认空间聚合 | 默认对所有序列求和 | ❌ 不改变（但是导数） | 
| per_minute(metric{...} by {pod_name}) | 时间导数 + 保留维度 | 每个 Pod 单独计算 | ❌ 不改变 | 


#### 🧠 如何避免混淆？

#### ✅ 记住这个规则：

> **Datadog 的函数如果没有显式 ****by {tag}****，就默认聚合所有匹配的时间序列。**


这适用于：

- per_minute(...)

- delta(...)

- increase(...)

- 等等